<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Halftone Comparison – 3 Algorithms</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      :root {
        --bg: #101218;
        --panel: #181b24;
        --panel-alt: #1f2330;
        --accent: #4fa3ff;
        --accent-soft: rgba(79, 163, 255, 0.18);
        --border-subtle: #2a3142;
        --text: #f5f7ff;
        --text-muted: #a3adc2;
        --danger: #ff6b7a;
        --radius-lg: 14px;
        --radius-md: 10px;
        --shadow-soft: 0 18px 45px rgba(0, 0, 0, 0.45);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 24px;
        font-family:
          system-ui,
          -apple-system,
          BlinkMacSystemFont,
          "Segoe UI",
          sans-serif;
        background: radial-gradient(
          circle at top,
          #1e2433,
          #05060a 52%,
          #020308
        );
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: stretch;
      }

      .app-shell {
        max-width: 1280px;
        margin: 0 auto;
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      header {
        display: flex;
        flex-wrap: wrap;
        align-items: flex-end;
        justify-content: space-between;
        gap: 12px 20px;
      }

      header .title-block {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      header h1 {
        margin: 0;
        font-size: 1.4rem;
        letter-spacing: 0.04em;
      }

      header p {
        margin: 0;
        font-size: 0.86rem;
        color: var(--text-muted);
      }

      .file-input-wrap {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 8px 12px;
        border-radius: 999px;
        background: linear-gradient(135deg, #202534, #131724);
        border: 1px solid var(--border-subtle);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        color: var(--text-muted);
        font-size: 0.85rem;
        white-space: nowrap;
      }

      .file-input-wrap input[type="file"] {
        max-width: 220px;
        color: var(--text);
      }

      .file-input-wrap small {
        color: var(--text-muted);
      }

      .controls-panel {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 12px 18px;
        background: rgba(7, 10, 20, 0.9);
        border-radius: var(--radius-lg);
        padding: 14px 16px 10px;
        border: 1px solid rgba(255, 255, 255, 0.06);
        box-shadow: var(--shadow-soft);
        backdrop-filter: blur(16px);
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 0;
      }

      .control-label {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        font-size: 0.82rem;
        color: var(--text-muted);
      }

      .control-label span.value {
        color: var(--accent);
        font-variant-numeric: tabular-nums;
        font-size: 0.8rem;
      }

      input[type="range"] {
        width: 100%;
        accent-color: var(--accent);
      }

      .toggle-row {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.86rem;
        color: var(--text-muted);
      }

      .toggle-row input[type="checkbox"] {
        width: 18px;
        height: 18px;
        accent-color: var(--accent);
      }

      .main-layout {
        margin-top: 4px;
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .canvas-row {
        display: flex;
        flex-wrap: wrap;
        gap: 14px;
      }

      .canvas-panel {
        flex: 1 1 260px;
        min-width: 0;
        background: var(--panel);
        border-radius: var(--radius-lg);
        border: 1px solid var(--border-subtle);
        box-shadow: var(--shadow-soft);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .panel-header {
        padding: 10px 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.04);
        background: linear-gradient(
          135deg,
          rgba(37, 45, 72, 0.9),
          rgba(24, 27, 36, 0.95)
        );
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      .panel-title {
        font-size: 0.86rem;
        font-weight: 600;
      }

      .panel-subtitle {
        font-size: 0.73rem;
        color: var(--text-muted);
      }

      .canvas-wrap {
        position: relative;
        background: radial-gradient(circle at top, #262c3d, #151822);
        padding: 10px;
      }

      canvas {
        display: block;
        width: 100%;
        height: auto;
        border-radius: var(--radius-md);
        background: #fff;
      }

      .panel-footer {
        padding: 8px 10px 10px;
        border-top: 1px solid rgba(255, 255, 255, 0.04);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        background: var(--panel-alt);
      }

      .export-btn {
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: radial-gradient(
          circle at top left,
          var(--accent-soft),
          rgba(11, 15, 24, 0.9)
        );
        color: var(--text);
        font-size: 0.8rem;
        padding: 6px 10px;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .export-btn:hover {
        border-color: var(--accent);
        box-shadow: 0 0 0 1px rgba(79, 163, 255, 0.3);
      }

      .hint {
        font-size: 0.72rem;
        color: var(--text-muted);
      }

      .status-bar {
        font-size: 0.76rem;
        color: var(--text-muted);
        display: flex;
        justify-content: space-between;
        margin-top: 2px;
        padding: 0 2px 2px;
      }

      .status-bar .warning {
        color: var(--danger);
      }

      @media (max-width: 700px) {
        body {
          padding: 16px;
        }

        header h1 {
          font-size: 1.2rem;
        }

        .controls-panel {
          padding: 12px;
        }
      }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <header>
        <div class="title-block">
          <h1>Halftone Comparison Lab</h1>
          <p>
            Compare mechanical, stochastic, and artistic halftone styles from a
            single source image.
          </p>
        </div>
        <div class="file-input-wrap">
          <label for="imageLoader">Upload image</label>
          <input id="imageLoader" type="file" accept="image/*" />
          <small id="imageInfo">No image loaded</small>
        </div>
      </header>

      <section class="controls-panel" aria-label="Halftone controls">
        <div class="control-group">
          <label class="control-label" for="gridSpacing">
            <span>Grid spacing</span>
            <span class="value" id="gridSpacingValue"></span>
          </label>
          <input
            id="gridSpacing"
            type="range"
            min="1"
            max="40"
            step="1"
            value="12"
          />
        </div>

        <div class="control-group">
          <label class="control-label" for="dotSizeStep">
            <span>Dot size (3 sizes)</span>
            <span class="value" id="dotSizeStepValue"></span>
          </label>
          <input
            id="dotSizeStep"
            type="range"
            min="0"
            max="20"
            step="1"
            value="0"
          />
          <div class="hint">
            Small / medium / large: 0.3, 0.6, 0.9 px + step×0.3 (Type 1 & 3).
          </div>
        </div>

        <div class="control-group">
          <label class="control-label" for="contrastMultiplier">
            <span>Contrast multiplier</span>
            <span class="value" id="contrastMultiplierValue"></span>
          </label>
          <input
            id="contrastMultiplier"
            type="range"
            min="0.5"
            max="2.5"
            step="0.05"
            value="1.1"
          />
        </div>

        <div class="control-group">
          <label class="control-label" for="shadowsLevel">
            <span>Shadows (black point)</span>
            <span class="value" id="shadowsLevelValue"></span>
          </label>
          <input
            id="shadowsLevel"
            type="range"
            min="0"
            max="0.5"
            step="0.01"
            value="0"
          />
          <div class="hint">Higher = crush shadows (darken darks).</div>
        </div>

        <div class="control-group">
          <label class="control-label" for="midtonesLevel">
            <span>Midtones (gamma)</span>
            <span class="value" id="midtonesLevelValue"></span>
          </label>
          <input
            id="midtonesLevel"
            type="range"
            min="0.5"
            max="2"
            step="0.05"
            value="1"
          />
          <div class="hint">&lt;1 darken, &gt;1 brighten midtones.</div>
        </div>

        <div class="control-group">
          <label class="control-label" for="highlightsLevel">
            <span>Highlights (white point)</span>
            <span class="value" id="highlightsLevelValue"></span>
          </label>
          <input
            id="highlightsLevel"
            type="range"
            min="0.5"
            max="1"
            step="0.01"
            value="1"
          />
          <div class="hint">Lower = clip highlights (brighten brights).</div>
        </div>

        <div class="control-group">
          <label class="control-label" for="dotCountFactor">
            <span>Dot count</span>
            <span class="value" id="dotCountFactorValue"></span>
          </label>
          <input
            id="dotCountFactor"
            type="range"
            min="0.25"
            max="2"
            step="0.05"
            value="1"
          />
          <div class="hint">Scale dots vs default: &lt;1 remove, &gt;1 add.</div>
        </div>

        <div class="control-group">
          <label class="control-label" for="dotShape">
            <span>Dot shape</span>
          </label>
          <select id="dotShape">
            <option value="circle" selected>Circle</option>
            <option value="square">Square</option>
          </select>
          <div class="hint">Switch between circular or square “dots”.</div>
        </div>

        <div class="control-group">
          <div class="toggle-row">
            <input id="brightnessDetectionToggle" type="checkbox" />
            <label for="brightnessDetectionToggle"
              >Brightness / white detection</label
            >
          </div>
          <select id="brightnessMethod">
            <option value="center">Center – single pixel at cell center</option>
            <option value="mean" selected>
              Mean – average luminance in cell
            </option>
            <option value="median">Median – median luminance in cell</option>
            <option value="max">Max – brightest pixel in cell</option>
            <option value="p95">95th percentile – emphasize bright area</option>
          </select>
          <div class="hint">
            When enabled, summarizes “white” per cell (Type 1 & 4). Uncheck to
            use center pixel only.
          </div>
        </div>

        <div class="control-group">
          <label class="control-label" for="placementRule">
            <span>Placement (Type 2 & 3, white detection off)</span>
          </label>
          <select id="placementRule">
            <option value="grid">Grid – strict cell centers</option>
            <option value="gridJitter" selected>
              Grid + Jitter – offset within cell
            </option>
            <option value="poissonDisc">Poisson-disc – random (legacy)</option>
            <option value="poissonDiscEven">
              Poisson-disc – even, no overlap
            </option>
            <option value="poissonDiscBridson">
              Poisson-disc – blue noise (Bridson)
            </option>
            <option value="rotatedGrid">Rotated grid – lattice, thresholded</option>
            <option value="rotatedGridToneSpacing">
              Rotated grid – tone-based spacing
            </option>
            <option value="staggeredGrid">
              Staggered grid – brick/offset rows
            </option>
            <option value="hexagonal">Hexagonal – honeycomb centers</option>
            <option value="randomScatter">
              Random scatter – uniform random, can overlap
            </option>
          </select>
          <div class="hint">
            Only applies to Type 2 & 3 when brightness detection is unchecked.
          </div>
        </div>

        <div class="control-group">
          <label class="control-label" for="rotatedGridAngle">
            <span>Rotated grid angle</span>
            <span class="value" id="rotatedGridAngleValue"></span>
          </label>
          <input
            id="rotatedGridAngle"
            type="range"
            min="0"
            max="90"
            step="1"
            value="45"
          />
          <div class="hint">
            Angle for the rotated grid placement rule (degrees). 45° mimics
            classic print screens.
          </div>
        </div>

        <div class="control-group">
          <label class="control-label" for="rotatedGridThreshold">
            <span>Rotated grid threshold</span>
            <span class="value" id="rotatedGridThresholdValue"></span>
          </label>
          <input
            id="rotatedGridThreshold"
            type="range"
            min="0"
            max="0.3"
            step="0.005"
            value="0.05"
          />
          <div class="hint">
            Brightness cutoff when using rotated grid placement. Higher =
            fewer dots.
          </div>
        </div>

        <div class="control-group">
          <label class="control-label" for="rotatedGridToneSpacing">
            <span>Rotated grid tone spacing</span>
            <span class="value" id="rotatedGridToneSpacingValue"></span>
          </label>
          <input
            id="rotatedGridToneSpacing"
            type="range"
            min="0"
            max="100"
            step="0.5"
            value="1"
          />
          <div class="hint">
            Extra spacing in darker tones when using rotated grid – tone-based
            spacing. 0 = uniform spacing, higher values (up to 100×) thin dots
            more in dark areas.
          </div>
        </div>

        <div class="control-group">
          <div class="toggle-row">
            <input id="type1KeepLatticeToggle" type="checkbox" />
            <label for="type1KeepLatticeToggle">
              Type 1: keep lattice (variable dot size only)
            </label>
          </div>
          <div class="hint">
            When enabled, Type 1 keeps every grid cell (no dot removal) and
            maps dot size from brightness instead of turning dots on/off.
          </div>
        </div>

        <div class="control-group">
          <div class="toggle-row">
            <input id="type3KeepLatticeToggle" type="checkbox" />
            <label for="type3KeepLatticeToggle">
              Type 3: keep lattice (variable dot size only)
            </label>
          </div>
          <div class="hint">
            When enabled, Type 3 uses the full placement lattice (no dot
            removal) and maps dot size directly from brightness instead of
            turning dots on/off.
          </div>
        </div>

        <div class="control-group">
          <label class="control-label" for="poissonMinDistance">
            <span>Poisson min distance</span>
            <span class="value" id="poissonMinDistanceValue"></span>
          </label>
          <input
            id="poissonMinDistance"
            type="range"
            min="0.3"
            max="10"
            step="0.1"
            value="1"
          />
          <div class="hint">
            Scale for min distance between dots when Poisson-disc is selected.
            Lower = denser.
          </div>
        </div>

        <div class="control-group">
          <div class="toggle-row">
            <input id="invertToggle" type="checkbox" />
            <label for="invertToggle">Invert brightness</label>
          </div>
          <div class="hint">
            Useful when preparing for dark substrates or inverted stencils.
          </div>
        </div>
      </section>

      <section class="main-layout">
        <div class="canvas-row">
          <article class="canvas-panel">
            <div class="panel-header">
              <div class="panel-title">Type 1 – Fixed Grid + Variable Size</div>
              <div class="panel-subtitle">
                Mechanical halftone suitable for rhinestone / bead machines.
              </div>
            </div>
            <div class="canvas-wrap">
              <canvas id="canvas1" width="600" height="400"></canvas>
            </div>
            <div class="panel-footer">
              <div>
                <label class="toggle-row">
                  <input type="checkbox" class="type-toggle" data-type="1" />
                  <span>Apply effect</span>
                </label>
              </div>
              <div>
                <button class="export-btn" data-type="1">
                  <span>Export SVG</span>
                </button>
              </div>
            </div>
          </article>

          <article class="canvas-panel">
            <div class="panel-header">
              <div class="panel-title">
                Type 2 – Fixed Size + Variable Density
              </div>
              <div class="panel-subtitle">
                Dots at brightness peaks (local maxima); fixed size, no grid, no
                random.
              </div>
            </div>
            <div class="canvas-wrap">
              <canvas id="canvas2" width="600" height="400"></canvas>
            </div>
            <div class="panel-footer">
              <div>
                <label class="toggle-row">
                  <input type="checkbox" class="type-toggle" data-type="2" />
                  <span>Apply effect</span>
                </label>
              </div>
              <div>
                <button class="export-btn" data-type="2">
                  <span>Export SVG</span>
                </button>
              </div>
            </div>
          </article>

          <article class="canvas-panel">
            <div class="panel-header">
              <div class="panel-title">
                Type 3 – Variable Size + White-Detection Position
              </div>
              <div class="panel-subtitle">
                Dots at brightness peaks; size from peak brightness, no grid, no
                random.
              </div>
            </div>
            <div class="canvas-wrap">
              <canvas id="canvas3" width="600" height="400"></canvas>
            </div>
            <div class="panel-footer">
              <div>
                <label class="toggle-row">
                  <input type="checkbox" class="type-toggle" data-type="3" />
                  <span>Apply effect</span>
                </label>
              </div>
              <div>
                <button class="export-btn" data-type="3">
                  <span>Export SVG</span>
                </button>
              </div>
            </div>
          </article>

          <article class="canvas-panel">
            <div class="panel-header">
              <div class="panel-title">Type 4 – Fixed Grid + Fixed Size</div>
              <div class="panel-subtitle">
                Uniform grid with constant dot size, gated by brightness.
              </div>
            </div>
            <div class="canvas-wrap">
              <canvas id="canvas4" width="600" height="400"></canvas>
            </div>
            <div class="panel-footer">
              <div>
                <label class="toggle-row">
                  <input type="checkbox" class="type-toggle" data-type="4" />
                  <span>Apply effect</span>
                </label>
              </div>
              <div>
                <button class="export-btn" data-type="4">
                  <span>Export SVG</span>
                </button>
              </div>
            </div>
          </article>
        </div>

        <div class="status-bar">
          <span id="statusText">Upload an image to begin.</span>
          <span id="perfHint" class="warning"></span>
        </div>
      </section>
    </div>

    <script>
      // ---------- Global state ----------

      const state = {
        width: 0,
        height: 0,
        grayBuffer: null, // Float32Array of brightness 0–1 (non-inverted, non-contrast-adjusted)
        invert: false,
        levelsShadows: 0, // black point 0–0.5
        levelsMidtones: 1, // gamma 0.5–2
        levelsHighlights: 1, // white point 0.5–1
        dotCountFactor: 1, // 0.25–2: scale dots vs default
        gridSpacing: 12,
        dotSizeStep: 0, // 0 → sizes 0.5, 1, 1.5 px; 1 → 1, 1.5, 2; etc.
        contrastMultiplier: 1.1,
        dotShape: "circle",
        brightnessMethod: "mean",
        brightnessDetectionEnabled: false,
        placementRule: "gridJitter",
        poissonMinDistanceScale: 1, // scale for min distance in Poisson-disc (0.3–2.5)
        rotatedGridAngleDeg: 45, // 0–90, for rotated grid placement
        rotatedGridThreshold: 0.05, // 0–0.3, brightness cutoff for rotated grid
        type1KeepLattice: false, // Type 1: keep every grid cell, vary radius from brightness
        type3KeepLattice: false, // Option C: keep lattice and vary radius instead of removing
        rotatedGridToneSpacingStrength: 1, // strength for tone-based spacing (0–2)
        enabledTypes: {
          1: false,
          2: false,
          3: false,
          4: false,
        },
        needsRender: false,
        dotsCache: {
          1: null,
          2: null,
          3: null,
          4: null,
        },
      };

      const MAX_DIMENSION = 1000; // downscale large uploads

      const canvases = {};

      // ---------- Utility: seeded PRNG (mulberry32) ----------

      function mulberry32(a) {
        let t = a >>> 0;
        return function () {
          t += 0x6d2b79f5;
          let r = Math.imul(t ^ (t >>> 15), t | 1);
          r ^= r + Math.imul(r ^ (r >>> 7), r | 61);
          return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
        };
      }

      // ---------- Brightness helpers ----------

      function clamp01(x) {
        return x < 0 ? 0 : x > 1 ? 1 : x;
      }

      function applyContrast(b, contrast) {
        // Center-based contrast: expand or compress around 0.5
        const c = contrast;
        if (Math.abs(c - 1) < 1e-3) return clamp01(b);
        const v = 0.5 + (b - 0.5) * c;
        return clamp01(v);
      }

      function applyLevels(b, blackPoint, whitePoint, gamma) {
        // Levels adjustment: remap [blackPoint, whitePoint] → [0, 1], then gamma
        const span = Math.max(1e-6, whitePoint - blackPoint);
        let v = (b - blackPoint) / span;
        v = clamp01(v);
        if (Math.abs(gamma - 1) >= 0.02) v = Math.pow(v, 1 / gamma);
        return clamp01(v);
      }

      function getBrightnessFactory() {
        const {
          grayBuffer,
          width,
          height,
          invert,
          contrastMultiplier,
          levelsShadows,
          levelsMidtones,
          levelsHighlights,
        } = state;
        return function getBrightness(x, y) {
          if (!grayBuffer) return 0;
          const ix = Math.max(0, Math.min(width - 1, Math.round(x)));
          const iy = Math.max(0, Math.min(height - 1, Math.round(y)));
          const idx = iy * width + ix;
          let b = grayBuffer[idx]; // 0–1
          b = applyLevels(b, levelsShadows, levelsHighlights, levelsMidtones);
          if (invert) b = 1 - b;
          b = applyContrast(b, contrastMultiplier);
          return b;
        };
      }

      // ---------- Cell brightness (white detection) methods ----------
      // Each summarizes luminance over a grid cell so you can compare via dropdown.

      function getCellBrightness(cx, cy, cellSize) {
        const getBrightness = getBrightnessFactory();
        if (!state.brightnessDetectionEnabled) return getBrightness(cx, cy);
        const { width, height } = state;
        const x0 = Math.max(0, Math.floor(cx - cellSize / 2));
        const y0 = Math.max(0, Math.floor(cy - cellSize / 2));
        const x1 = Math.min(width, Math.ceil(cx + cellSize / 2));
        const y1 = Math.min(height, Math.ceil(cy + cellSize / 2));
        const values = [];
        for (let py = y0; py < y1; py++) {
          for (let px = x0; px < x1; px++) {
            values.push(getBrightness(px + 0.5, py + 0.5));
          }
        }
        if (values.length === 0) return 0;
        const method = state.brightnessMethod || "mean";
        if (method === "center") {
          const ix = Math.max(0, Math.min(width - 1, Math.round(cx)));
          const iy = Math.max(0, Math.min(height - 1, Math.round(cy)));
          return getBrightness(ix + 0.5, iy + 0.5);
        }
        if (method === "mean") {
          let sum = 0;
          for (let i = 0; i < values.length; i++) sum += values[i];
          return sum / values.length;
        }
        if (method === "median") {
          values.sort((a, b) => a - b);
          const mid = values.length >> 1;
          return values.length % 2 === 0
            ? (values[mid - 1] + values[mid]) / 2
            : values[mid];
        }
        if (method === "max") {
          let m = values[0];
          for (let i = 1; i < values.length; i++)
            if (values[i] > m) m = values[i];
          return m;
        }
        if (method === "p95") {
          values.sort((a, b) => a - b);
          const idx = Math.min(
            values.length - 1,
            Math.floor(values.length * 0.95),
          );
          return values[idx];
        }
        return values.reduce((a, b) => a + b, 0) / values.length;
      }

      // Returns { b, cx, cy } for variable-size dot at brightness centroid in cell.
      function getCellBrightnessAndCentroid(cx, cy, cellSize) {
        const getBrightness = getBrightnessFactory();
        const { width, height } = state;
        const x0 = Math.max(0, Math.floor(cx - cellSize / 2));
        const y0 = Math.max(0, Math.floor(cy - cellSize / 2));
        const x1 = Math.min(width, Math.ceil(cx + cellSize / 2));
        const y1 = Math.min(height, Math.ceil(cy + cellSize / 2));
        let sumB = 0,
          sumX = 0,
          sumY = 0;
        for (let py = y0; py < y1; py++) {
          for (let px = x0; px < x1; px++) {
            const b = getBrightness(px + 0.5, py + 0.5);
            sumB += b;
            sumX += (px + 0.5) * b;
            sumY += (py + 0.5) * b;
          }
        }
        const count = (x1 - x0) * (y1 - y0) || 1;
        const b = sumB / count;
        if (sumB <= 1e-9) return { b: 0, cx, cy };
        return {
          b,
          cx: sumX / sumB,
          cy: sumY / sumB,
        };
      }

      // ---------- White-detection placement: find brightness peaks (local maxima) ----------
      // Positions come from image content only: no fixed grid, no random.
      // Returns array of { x, y, b } with optional subpixel refinement.

      function findBrightnessPeaks(options) {
        const getBrightness = getBrightnessFactory();
        const { width, height } = state;
        const radius = Math.max(1, options.radius || 2); // neighborhood half-size (e.g. 2 => 5x5)
        const threshold = options.threshold != null ? options.threshold : 0.05;
        const minDist = options.minDist != null ? options.minDist : 0; // 0 = no filtering
        const step = Math.max(1, options.step || 1); // sample step (1 = every pixel)

        const peaks = [];
        const R = radius;
        for (let y = R; y < height - R; y += step) {
          for (let x = R; x < width - R; x += step) {
            const b0 = getBrightness(x + 0.5, y + 0.5);
            if (b0 < threshold) continue;
            let isMax = true;
            for (let dy = -R; dy <= R && isMax; dy++) {
              for (let dx = -R; dx <= R && isMax; dx++) {
                if (dx === 0 && dy === 0) continue;
                const b = getBrightness(x + dx + 0.5, y + dy + 0.5);
                if (b > b0) isMax = false;
              }
            }
            if (!isMax) continue;
            // Subpixel refinement: parabolic fit in x and y
            const bx0 = getBrightness(x - 1 + 0.5, y + 0.5);
            const bx1 = getBrightness(x + 1 + 0.5, y + 0.5);
            const by0 = getBrightness(x + 0.5, y - 1 + 0.5);
            const by1 = getBrightness(x + 0.5, y + 1 + 0.5);
            let cx = x + 0.5,
              cy = y + 0.5;
            const denomX = 2 * (bx0 - 2 * b0 + bx1);
            if (Math.abs(denomX) > 1e-6) {
              const offX = (bx0 - bx1) / denomX;
              if (offX >= -0.6 && offX <= 0.6) cx = x + 0.5 + offX;
            }
            const denomY = 2 * (by0 - 2 * b0 + by1);
            if (Math.abs(denomY) > 1e-6) {
              const offY = (by0 - by1) / denomY;
              if (offY >= -0.6 && offY <= 0.6) cy = y + 0.5 + offY;
            }
            peaks.push({ x: cx, y: cy, b: b0 });
          }
        }

        if (minDist > 0 && peaks.length > 0) {
          peaks.sort((a, b) => b.b - a.b);
          const kept = [peaks[0]];
          for (let i = 1; i < peaks.length; i++) {
            const p = peaks[i];
            let ok = true;
            for (let k = 0; k < kept.length; k++) {
              const q = kept[k];
              const dx = p.x - q.x,
                dy = p.y - q.y;
              if (dx * dx + dy * dy < minDist * minDist) {
                ok = false;
                break;
              }
            }
            if (ok) kept.push(p);
          }
          return kept;
        }
        return peaks;
      }

      // ---------- Image loading & grayscale preprocessing ----------

      function handleFileInput(event) {
        const file = event.target.files && event.target.files[0];
        if (!file) return;

        const infoEl = document.getElementById("imageInfo");
        infoEl.textContent = "Loading…";

        const reader = new FileReader();
        reader.onload = function (e) {
          const img = new Image();
          img.onload = function () {
            prepareGrayscale(img);
          };
          img.onerror = function () {
            infoEl.textContent = "Failed to load image.";
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      }

      function prepareGrayscale(img) {
        // Downscale large images for performance, preserving aspect ratio.
        const scale = Math.min(
          MAX_DIMENSION / img.width,
          MAX_DIMENSION / img.height,
          1,
        );
        const width = Math.round(img.width * scale);
        const height = Math.round(img.height * scale);

        const offscreen = document.createElement("canvas");
        offscreen.width = width;
        offscreen.height = height;
        const ctx = offscreen.getContext("2d", { willReadFrequently: true });
        ctx.drawImage(img, 0, 0, width, height);

        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        const len = width * height;
        const gray = new Float32Array(len);

        // Precompute grayscale buffer once using luminance formula:
        // brightness = 0.299R + 0.587G + 0.114B, normalized to 0–1
        for (let i = 0, j = 0; i < len; i++, j += 4) {
          const r = data[j];
          const g = data[j + 1];
          const b = data[j + 2];
          const lum = 0.299 * r + 0.587 * g + 0.114 * b;
          gray[i] = lum / 255;
        }

        state.width = width;
        state.height = height;
        state.grayBuffer = gray;
        state.dotsCache[1] = null;
        state.dotsCache[2] = null;
        state.dotsCache[3] = null;
        state.dotsCache[4] = null;

        const infoEl = document.getElementById("imageInfo");
        infoEl.textContent = `${width}×${height}`;

        document.getElementById("statusText").textContent =
          "Image loaded. Check which types to apply; changes update automatically.";
      }

      // ---------- Rendering coordination ----------

      function markNeedsRender() {
        // Clear caches to respect new parameters and trigger a re-render
        // for all currently enabled types.
        state.needsRender = true;
        state.dotsCache[1] = null;
        state.dotsCache[2] = null;
        state.dotsCache[3] = null;
        state.dotsCache[4] = null;
      }

      function resizeCanvases() {
        const { width, height } = state;
        if (!width || !height) return;
        for (const key of [1, 2, 3, 4]) {
          const canvas = canvases[key];
          if (!canvas) continue;
          canvas.width = width;
          canvas.height = height;
        }
      }

      function drawDotsToCanvas(ctx, dots) {
        const { width, height, dotShape } = state;
        // Dark background with white dots: this reads correctly as “light = ink”
        // when viewed on screen or exported as SVG.
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillStyle = "#05060a";
        ctx.fillRect(0, 0, width, height);
        ctx.restore();

        if (!dots || dots.length === 0) return;

        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        if (dotShape === "square") {
          // Draw axis-aligned squares centred on (x, y)
          for (let i = 0; i < dots.length; i++) {
            const d = dots[i];
            if (d.r <= 0) continue;
            const size = d.r * 2;
            ctx.rect(d.x - d.r, d.y - d.r, size, size);
          }
        } else {
          // Default: circular dots
          for (let i = 0; i < dots.length; i++) {
            const d = dots[i];
            if (d.r <= 0) continue;
            ctx.moveTo(d.x + d.r, d.y);
            ctx.arc(d.x, d.y, d.r, 0, Math.PI * 2);
          }
        }
        ctx.fill();
      }

      // Three discrete dot sizes: small, medium, large. Step 0 = 0.3, 0.6, 0.9 px; step 1 = 0.6, 0.9, 1.2 px; etc. (0.3 increment).
      function getDotSizes() {
        const step = state.dotSizeStep || 0;
        const round = (v) => Math.round(v * 100) / 100; // avoid 0.899999...
        const base = round(0.3 + step * 0.3);
        return {
          small: base,
          medium: round(base + 0.3),
          large: round(base + 0.6),
        };
      }

      function buildCommonParams() {
        return {
          width: state.width,
          height: state.height,
          grayBuffer: state.grayBuffer,
          getBrightness: getBrightnessFactory(),
          gridSpacing: state.gridSpacing,
          dotSizes: getDotSizes(),
          contrast: state.contrastMultiplier,
          invert: state.invert,
          dotCountFactor: state.dotCountFactor,
        };
      }

      // Apply dot count factor: subsample (factor<1) or use full set (factor>=1).
      // When reducing: keep brightest dots first.
      function applyDotCountFactor(dots, factor, getBrightness) {
        if (!dots || dots.length === 0 || factor >= 1) return dots;
        const n = Math.max(1, Math.floor(dots.length * factor));
        if (n >= dots.length) return dots;
        const withB = dots.map((d) => ({
          d,
          b: getBrightness ? getBrightness(d.x, d.y) : (d.r || 0),
        }));
        withB.sort((a, b) => b.b - a.b);
        return withB.slice(0, n).map((x) => x.d);
      }

      // ---------- Algorithm: Type 1 – Fixed Grid + Variable Size ----------
      // Mechanical halftone: every grid cell contains at most one dot, positioned
      // at the cell center. Dot radius encodes brightness (white → large, black → none).
      // Brightness per cell uses the selected detection method (center / mean / median / max / p95).

      function computeDotsType1(params) {
        const { width, height, gridSpacing, dotSizes, dotCountFactor = 1 } =
          params;
        const dots = [];
        const eff = dotCountFactor > 1 ? Math.sqrt(dotCountFactor) : 1;
        const cell = Math.max(2, gridSpacing / eff);
        const sizes = [dotSizes.small, dotSizes.medium, dotSizes.large];
        const keepLattice = !!state.type1KeepLattice;

        for (let y = 0; y < height; y += cell) {
          const cy = y + cell / 2;
          for (let x = 0; x < width; x += cell) {
            const cx = x + cell / 2;
            const b = getCellBrightness(cx, cy, cell);
            const bb = clamp01(b);
            if (!keepLattice && bb <= 0.001) continue;
            let r;
            if (keepLattice) {
              const minR = dotSizes.small * 0.4;
              const maxR = dotSizes.large;
              r = minR + bb * (maxR - minR);
            } else {
              const bucket = Math.min(2, Math.floor(bb * 3)); // 0, 1, or 2
              r = sizes[bucket];
            }
            if (r <= 0.01) continue;
            dots.push({ x: cx, y: cy, r });
          }
        }
        return dots;
      }

      function renderType1(params) {
        let dots =
          state.dotsCache[1] || (state.dotsCache[1] = computeDotsType1(params));
        dots = applyDotCountFactor(
          dots,
          state.dotCountFactor,
          params.getBrightness,
        );
        const ctx = canvases[1].getContext("2d");
        drawDotsToCanvas(ctx, dots);
      }

      // ---------- Placement helpers (Type 2 & 3 when white detection off) ----------
      // Each returns a list of candidate positions; Type 2 uses prob + fixed r, Type 3 uses b for size.

      function placementGrid(width, height, cell, getBrightness) {
        const out = [];
        for (let y = 0; y < height; y += cell) {
          const cy = y + cell / 2;
          for (let x = 0; x < width; x += cell) {
            const cx = x + cell / 2;
            out.push({ x: cx, y: cy, b: getBrightness(cx, cy) });
          }
        }
        return out;
      }

      function placementGridJitter(
        width,
        height,
        cell,
        getBrightness,
        rng,
        jitterFactor,
      ) {
        const out = [];
        for (let y = 0; y < height; y += cell) {
          const cy = y + cell / 2;
          for (let x = 0; x < width; x += cell) {
            const cx = x + cell / 2;
            const jx = (rng() - 0.5) * jitterFactor * cell;
            const jy = (rng() - 0.5) * jitterFactor * cell;
            const px = Math.max(0, Math.min(width, cx + jx));
            const py = Math.max(0, Math.min(height, cy + jy));
            out.push({ x: px, y: py, b: getBrightness(cx, cy) });
          }
        }
        return out;
      }

      function placementStaggeredGrid(width, height, cell, getBrightness) {
        const out = [];
        const half = cell / 2;
        for (let row = 0; ; row++) {
          const cy = row * cell + half;
          if (cy >= height) break;
          const xOffset = (row % 2) * half;
          for (let col = 0; ; col++) {
            const cx = col * cell + half + xOffset;
            if (cx >= width) break;
            out.push({ x: cx, y: cy, b: getBrightness(cx, cy) });
          }
        }
        return out;
      }

      function placementHexagonal(width, height, cell, getBrightness) {
        const out = [];
        const dx = cell;
        const dy = (cell * Math.sqrt(3)) / 2;
        let row = 0;
        for (let cy = dy / 2; cy < height; cy += dy, row++) {
          const xOffset = (row % 2) * (cell / 2);
          for (let cx = xOffset + cell / 2; cx < width; cx += dx)
            out.push({ x: cx, y: cy, b: getBrightness(cx, cy) });
        }
        return out;
      }

      // Rotated grid at a fixed angle (e.g. 45°) with brightness sampled at
      // lattice points. Returns deterministic positions with associated
      // brightness, so calling code can apply a simple threshold or size
      // mapping without randomness.
      function placementRotatedGrid(
        width,
        height,
        cell,
        getBrightness,
        angleRad,
      ) {
        const out = [];
        const cosA = Math.cos(angleRad);
        const sinA = Math.sin(angleRad);
        const margin = Math.max(width, height);

        for (let x = -margin; x < width + margin; x += cell) {
          for (let y = -margin; y < height + margin; y += cell) {
            const rx = x * cosA - y * sinA;
            const ry = x * sinA + y * cosA;
            if (rx < 0 || rx >= width || ry < 0 || ry >= height) continue;
            const b = getBrightness(rx, ry);
            out.push({ x: rx, y: ry, b });
          }
        }
        return out;
      }

      // Small deterministic pseudo-random based on integer coordinates, so
      // thinning patterns are stable between renders but still "noisy".
      function pseudoRandomFromCoords(x, y) {
        let n =
          (Math.floor(x) * 73856093) ^ (Math.floor(y) * 19349663) ^ 0x9e3779b9;
        n = (n << 13) ^ n;
        const nn = (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff;
        return nn / 0x7fffffff;
      }

      function placementPoissonDiscDots(
        width,
        height,
        getBrightness,
        dotSizes,
        isType3,
        rngSeed,
        dotCountFactor,
      ) {
        const rng = mulberry32(rngSeed);
        const sizes = [dotSizes.small, dotSizes.medium, dotSizes.large];
        const maxR = dotSizes.large;
        const estimatedBase = (width * height) / 100;
        const baseMax = Math.min(15000, Math.round(estimatedBase * 2.5));
        const maxDots =
          dotCountFactor != null && dotCountFactor > 1
            ? Math.round(baseMax * dotCountFactor)
            : baseMax;
        const maxAttempts = Math.min(60000, maxDots * 8);
        const cellSize = Math.max(2, maxR * 2);
        const cols = Math.ceil(width / cellSize);
        const rows = Math.ceil(height / cellSize);
        const grid = new Array(cols * rows);
        for (let i = 0; i < grid.length; i++) grid[i] = [];
        const gridIndex = (ix, iy) => iy * cols + ix;
        const dots = [];
        let attempts = 0;
        while (attempts < maxAttempts && dots.length < maxDots) {
          attempts++;
          const x = rng() * width;
          const y = rng() * height;
          const b = getBrightness(x, y);
          if (b <= 0.001) continue;
          const r = isType3
            ? sizes[Math.min(2, Math.floor(b * 3))]
            : dotSizes.medium;
          if (r <= 0.12) continue;
          const minFactorBright = 1.1;
          const minFactorDark = 2.6;
          const factor = minFactorDark * (1 - b) + minFactorBright * b;
          const scale =
            state.poissonMinDistanceScale != null
              ? state.poissonMinDistanceScale
              : 1;
          const dMin = r * factor * scale;
          const dMinSq = dMin * dMin;
          const ix = Math.floor(x / cellSize);
          const iy = Math.floor(y / cellSize);
          let ok = true;
          for (let gy = iy - 1; gy <= iy + 1 && ok; gy++) {
            if (gy < 0 || gy >= rows) continue;
            for (let gx = ix - 1; gx <= ix + 1 && ok; gx++) {
              if (gx < 0 || gx >= cols) continue;
              const cellList = grid[gridIndex(gx, gy)];
              for (let i = 0; i < cellList.length; i++) {
                const p = dots[cellList[i]];
                const dx = p.x - x,
                  dy = p.y - y;
                if (dx * dx + dy * dy < dMinSq) {
                  ok = false;
                  break;
                }
              }
            }
          }
          if (!ok) continue;
          dots.push({ x, y, r });
          grid[gridIndex(ix, iy)].push(dots.length - 1);
        }
        return dots;
      }

      // Variant Poisson-disc placement that enforces no visual overlap between dots
      // and uses brightness-driven spacing for dense-but-even highlights and
      // sparse-but-even shadows. This aims to approximate the very clean, even
      // distribution seen in the reference image.
      function placementPoissonDiscDotsEven(
        width,
        height,
        getBrightness,
        dotSizes,
        isType3,
        rngSeed,
        dotCountFactor,
      ) {
        const rng = mulberry32(rngSeed);
        const sizes = [dotSizes.small, dotSizes.medium, dotSizes.large];
        const maxR = dotSizes.large;

        // Internal scale for spacing. UI allows values <1, but we never allow
        // effective spacing to go below the "no-overlap" limit.
        const uiScale =
          state.poissonMinDistanceScale != null
            ? state.poissonMinDistanceScale
            : 1;
        const spacingScale = Math.max(1, uiScale);

        // Estimate a safe upper bound on dot count so we keep performance reasonable.
        const estimatedBase = (width * height) / 120;
        const baseMax = Math.min(14000, Math.round(estimatedBase * 2.2));
        const maxDots =
          dotCountFactor != null && dotCountFactor > 1
            ? Math.round(baseMax * dotCountFactor)
            : baseMax;
        const maxAttempts = Math.min(70000, maxDots * 10);

        // Use the largest expected spacing as a uniform grid cell to look up neighbours.
        // cellSize approximately equals the maximum expected min distance so neighbours
        // that could violate spacing live within a small neighbourhood of cells.
        const cellSize = Math.max(2, maxR * 2.2 * spacingScale);
        const cols = Math.ceil(width / cellSize);
        const rows = Math.ceil(height / cellSize);
        const grid = new Array(cols * rows);
        for (let i = 0; i < grid.length; i++) grid[i] = [];
        const gridIndex = (ix, iy) => iy * cols + ix;

        const dots = [];
        let attempts = 0;

        while (attempts < maxAttempts && dots.length < maxDots) {
          attempts++;
          const x = rng() * width;
          const y = rng() * height;
          const b = getBrightness(x, y);
          // Skip very dark pixels entirely so shadows stay sparse.
          if (b <= 0.015) continue;
          // Additional probabilistic thinning by brightness so dark areas become
          // sparser even when the geometric packing limit would allow more points.
          const acceptProb = b * b; // strong emphasis on bright areas
          if (rng() > acceptProb) continue;

          const r = isType3
            ? sizes[Math.min(2, Math.floor(b * 3))]
            : dotSizes.medium;
          if (r <= 0.12) continue;

          const ix = Math.floor(x / cellSize);
          const iy = Math.floor(y / cellSize);
          let ok = true;
          // Search neighbouring cells out to a small fixed radius; with our
          // choice of cellSize this comfortably covers all neighbours that
          // could violate spacing.
          for (let gy = iy - 2; gy <= iy + 2 && ok; gy++) {
            if (gy < 0 || gy >= rows) continue;
            for (let gx = ix - 2; gx <= ix + 2 && ok; gx++) {
              if (gx < 0 || gx >= cols) continue;
              const cellList = grid[gridIndex(gx, gy)];
              for (let i = 0; i < cellList.length; i++) {
                const p = dots[cellList[i]];
                const dx = p.x - x;
                const dy = p.y - y;
                // Pair-wise minimum distance uses the *sum* of radii so dots
                // never overlap, then scaled by spacingScale so the slider
                // pushes them further apart but never closer than tangent.
                const baseNoOverlap = (r + p.r) * 1.05; // small safety margin
                const minPair = baseNoOverlap * spacingScale;
                if (dx * dx + dy * dy < minPair * minPair) {
                  ok = false;
                  break;
                }
              }
            }
          }
          if (!ok) continue;

          dots.push({ x, y, r });
          grid[gridIndex(ix, iy)].push(dots.length - 1);
        }

        return dots;
      }

      // Bridson Poisson-disc (blue noise) sampler. Generates candidate points
      // in an approximately uniform blue-noise pattern, then we gate by
      // brightness and, for Type 3, map dot radius from brightness.
      function placementPoissonDiscBridson(
        width,
        height,
        getBrightness,
        dotSizes,
        isType3,
        rngSeed,
        dotCountFactor,
      ) {
        const rng = mulberry32(rngSeed);
        const sizes = [dotSizes.small, dotSizes.medium, dotSizes.large];

        // Base minimum distance derived from medium dot size and scaled by UI.
        const uiScale =
          state.poissonMinDistanceScale != null
            ? state.poissonMinDistanceScale
            : 1;
        const baseR = dotSizes.medium || 1;
        const minDist = Math.max(1, baseR * 2.2 * uiScale);
        const k = 30; // attempts per active point

        const cellSize = minDist / Math.SQRT2;
        const cols = Math.ceil(width / cellSize);
        const rows = Math.ceil(height / cellSize);
        const grid = new Array(cols * rows).fill(null);
        const gridIndex = (x, y) =>
          Math.floor(y / cellSize) * cols + Math.floor(x / cellSize);

        const samples = [];
        const active = [];

        function addSample(x, y) {
          const s = { x, y };
          samples.push(s);
          active.push(s);
          grid[gridIndex(x, y)] = s;
        }

        // Seed with a single point roughly centred for reproducibility.
        addSample(width * 0.5, height * 0.5);

        while (active.length) {
          const idx = Math.floor(rng() * active.length);
          const s = active[idx];
          let found = false;

          for (let i = 0; i < k; i++) {
            const angle = rng() * Math.PI * 2;
            const radius = minDist * (1 + rng());
            const x = s.x + Math.cos(angle) * radius;
            const y = s.y + Math.sin(angle) * radius;
            if (x < 0 || x >= width || y < 0 || y >= height) continue;

            let ok = true;
            const gx = Math.floor(x / cellSize);
            const gy = Math.floor(y / cellSize);
            for (let yy = Math.max(gy - 2, 0); yy <= Math.min(gy + 2, rows - 1); yy++) {
              for (
                let xx = Math.max(gx - 2, 0);
                xx <= Math.min(gx + 2, cols - 1);
                xx++
              ) {
                const neighbour = grid[yy * cols + xx];
                if (!neighbour) continue;
                const dx = neighbour.x - x;
                const dy = neighbour.y - y;
                if (dx * dx + dy * dy < minDist * minDist) {
                  ok = false;
                  break;
                }
              }
              if (!ok) break;
            }

            if (ok) {
              addSample(x, y);
              found = true;
              break;
            }
          }

          if (!found) {
            active[idx] = active[active.length - 1];
            active.pop();
          }
        }

        if (!samples.length) return [];

        const dots = [];
        const brightnessCut = 0.02;
        for (let i = 0; i < samples.length; i++) {
          const { x, y } = samples[i];
          const b = getBrightness(x, y);
          if (b <= brightnessCut) continue;

          if (isType3) {
            const bucket = Math.min(2, Math.floor(b * 3));
            const r = sizes[bucket];
            if (r <= 0.01) continue;
            dots.push({ x, y, r });
          } else {
            const r = dotSizes.medium;
            if (r <= 0.01) continue;
            dots.push({ x, y, r });
          }
        }

        // Respect dotCountFactor by subsampling brightest positions if needed.
        const maxDots =
          dotCountFactor != null && dotCountFactor > 1
            ? Math.round(dots.length * dotCountFactor)
            : dots.length;
        if (dots.length > maxDots) {
          const getB = getBrightness;
          const withB = dots.map((d) => ({ d, b: getB(d.x, d.y) }));
          withB.sort((a, b) => b.b - a.b);
          return withB.slice(0, maxDots).map((x) => x.d);
        }
        return dots;
      }

      function placementRandomScatter(
        width,
        height,
        getBrightness,
        dotSizes,
        isType3,
        rngSeed,
        maxDots,
      ) {
        const rng = mulberry32(rngSeed);
        const sizes = [dotSizes.small, dotSizes.medium, dotSizes.large];
        const dots = [];
        const cap = Math.min(maxDots || 12000, (width * height) / 4);
        const threshold = 0.05;
        for (let i = 0; i < cap * 3; i++) {
          if (dots.length >= cap) break;
          const x = rng() * width;
          const y = rng() * height;
          const b = getBrightness(x, y);
          if (b < threshold) continue;
          const r = isType3
            ? sizes[Math.min(2, Math.floor(b * 3))]
            : dotSizes.medium;
          dots.push({ x, y, r });
        }
        return dots;
      }

      // ---------- Algorithm: Type 2 – Fixed Size + Variable Density ----------
      // When white detection on: dots at brightness peaks. When off: use placementRule (grid / gridJitter / poissonDisc / etc.).

      function computeDotsType2(params) {
        const {
          width,
          height,
          gridSpacing,
          dotSizes,
          getBrightness,
          contrast,
          dotCountFactor = 1,
        } = params;
        const dots = [];
        const r = dotSizes.medium;
        if (r <= 0.01) return dots;
        const eff = dotCountFactor > 1 ? Math.sqrt(dotCountFactor) : 1;

        if (!state.brightnessDetectionEnabled) {
          const cell = Math.max(2, gridSpacing / eff);
          const rule = state.placementRule || "gridJitter";
          const rng = mulberry32(1337);

          if (rule === "poissonDisc") {
            const list = placementPoissonDiscDots(
              width,
              height,
              getBrightness,
              dotSizes,
              false,
              1337,
              dotCountFactor,
            );
            return list;
          }
          if (rule === "poissonDiscBridson") {
            return placementPoissonDiscBridson(
              width,
              height,
              getBrightness,
              dotSizes,
              false,
              7331,
              dotCountFactor,
            );
          }
          if (rule === "poissonDiscEven") {
            const list = placementPoissonDiscDotsEven(
              width,
              height,
              getBrightness,
              dotSizes,
              false,
              1339,
              dotCountFactor,
            );
            return list;
          }
          if (rule === "rotatedGrid") {
            const angle =
              ((state.rotatedGridAngleDeg != null
                ? state.rotatedGridAngleDeg
                : 45) *
                Math.PI) /
              180;
            const candidates = placementRotatedGrid(
              width,
              height,
              cell,
              getBrightness,
              angle,
            );
            const threshold =
              state.rotatedGridThreshold != null
                ? state.rotatedGridThreshold
                : 0.05;
            for (let i = 0; i < candidates.length; i++) {
              const { x, y, b } = candidates[i];
              if (b <= threshold) continue;
              dots.push({ x, y, r });
            }
            return dots;
          }
          if (rule === "rotatedGridToneSpacing") {
            const angle =
              ((state.rotatedGridAngleDeg != null
                ? state.rotatedGridAngleDeg
                : 45) *
                Math.PI) /
              180;
            const candidates = placementRotatedGrid(
              width,
              height,
              cell,
              getBrightness,
              angle,
            );
            const strengthRaw =
              state.rotatedGridToneSpacingStrength != null
                ? state.rotatedGridToneSpacingStrength
                : 1;
            const s = Math.max(0, strengthRaw);
            for (let i = 0; i < candidates.length; i++) {
              const { x, y, b } = candidates[i];
              const bb = clamp01(b);
              if (bb <= 0.001) continue;
              // Blue-ish tone spacing: keep probability falls off as brightness
              // to a high power so dark tones thin out strongly when s is large.
              const exponent = 1 + s; // s up to 100 → very strong falloff
              const keepProb = Math.pow(bb, exponent);
              const noise = pseudoRandomFromCoords(x, y);
              if (noise > keepProb) continue;
              dots.push({ x, y, r });
            }
            return dots;
          }
          if (rule === "randomScatter") {
            return placementRandomScatter(
              width,
              height,
              getBrightness,
              dotSizes,
              false,
              1338,
              Math.round(12000 * dotCountFactor),
            );
          }

          let candidates;
          if (rule === "grid")
            candidates = placementGrid(width, height, cell, getBrightness);
          else if (rule === "gridJitter")
            candidates = placementGridJitter(
              width,
              height,
              cell,
              getBrightness,
              rng,
              0.85,
            );
          else if (rule === "staggeredGrid")
            candidates = placementStaggeredGrid(
              width,
              height,
              cell,
              getBrightness,
            );
          else if (rule === "hexagonal")
            candidates = placementHexagonal(width, height, cell, getBrightness);
          else
            candidates = placementGridJitter(
              width,
              height,
              cell,
              getBrightness,
              rng,
              0.85,
            );

          for (let i = 0; i < candidates.length; i++) {
            const { x, y, b } = candidates[i];
            const p = Math.pow(clamp01(b), contrast);
            if (p <= 0) continue;
            if (rng() < p) dots.push({ x, y, r });
          }
          return dots;
        }

        const radius = Math.max(1, Math.floor((gridSpacing / eff) / 3));
        const minDist = Math.max(r * 1.2, 2);
        const thresh =
          dotCountFactor > 1
            ? Math.max(0.01, 0.05 * (2 - dotCountFactor))
            : 0.05;
        const peaks = findBrightnessPeaks({
          radius,
          threshold: thresh,
          minDist,
          step: 1,
        });
        for (let i = 0; i < peaks.length; i++)
          dots.push({ x: peaks[i].x, y: peaks[i].y, r });
        return dots;
      }

      function renderType2(params) {
        let dots =
          state.dotsCache[2] || (state.dotsCache[2] = computeDotsType2(params));
        dots = applyDotCountFactor(
          dots,
          state.dotCountFactor,
          params.getBrightness,
        );
        const ctx = canvases[2].getContext("2d");
        drawDotsToCanvas(ctx, dots);
      }

      // ---------- Algorithm: Type 3 – Variable Size + Position ----------
      // When white detection on: dots at brightness peaks. When off: use placementRule; size from brightness.

      function computeDotsType3(params) {
        const {
          width,
          height,
          gridSpacing,
          dotSizes,
          getBrightness,
          dotCountFactor = 1,
        } = params;
        const dots = [];
        if (!width || !height) return dots;
        const eff = dotCountFactor > 1 ? Math.sqrt(dotCountFactor) : 1;
        const sizes = [dotSizes.small, dotSizes.medium, dotSizes.large];

        if (!state.brightnessDetectionEnabled) {
          const cell = Math.max(2, gridSpacing / eff);
          const rule = state.placementRule || "gridJitter";

          if (rule === "poissonDisc") {
            const list = placementPoissonDiscDots(
              width,
              height,
              getBrightness,
              dotSizes,
              true,
              4242,
              dotCountFactor,
            );
            const perfHint = document.getElementById("perfHint");
            if (perfHint)
              perfHint.textContent = list.length
                ? ""
                : "Type 3: no dots (try lower threshold).";
            return list;
          }
          if (rule === "poissonDiscBridson") {
            const list = placementPoissonDiscBridson(
              width,
              height,
              getBrightness,
              dotSizes,
              true,
              7332,
              dotCountFactor,
            );
            const perfHint = document.getElementById("perfHint");
            if (perfHint) perfHint.textContent = "";
            return list;
          }
          if (rule === "poissonDiscEven") {
            const list = placementPoissonDiscDotsEven(
              width,
              height,
              getBrightness,
              dotSizes,
              true,
              4244,
              dotCountFactor,
            );
            const perfHint = document.getElementById("perfHint");
            if (perfHint) perfHint.textContent = "";
            return list;
          }
          if (rule === "rotatedGrid") {
            const angle =
              ((state.rotatedGridAngleDeg != null
                ? state.rotatedGridAngleDeg
                : 45) *
                Math.PI) /
              180;
            const candidates = placementRotatedGrid(
              width,
              height,
              cell,
              getBrightness,
              angle,
            );
            const threshold =
              state.rotatedGridThreshold != null
                ? state.rotatedGridThreshold
                : 0.05;
            for (let i = 0; i < candidates.length; i++) {
              const { x, y, b } = candidates[i];
              if (b <= threshold) continue;
              const bucket = Math.min(2, Math.floor(b * 3));
              const r = sizes[bucket];
              if (r <= 0.01) continue;
              dots.push({ x, y, r });
            }
            const perfHint = document.getElementById("perfHint");
            if (perfHint) perfHint.textContent = "";
            return dots;
          }
          if (rule === "rotatedGridToneSpacing") {
            const angle =
              ((state.rotatedGridAngleDeg != null
                ? state.rotatedGridAngleDeg
                : 45) *
                Math.PI) /
              180;
            const candidates = placementRotatedGrid(
              width,
              height,
              cell,
              getBrightness,
              angle,
            );
            const strengthRaw =
              state.rotatedGridToneSpacingStrength != null
                ? state.rotatedGridToneSpacingStrength
                : 1;
            const s = Math.max(0, strengthRaw);
            const keepLattice = !!state.type3KeepLattice;
            for (let i = 0; i < candidates.length; i++) {
              const { x, y, b } = candidates[i];
              const bb = clamp01(b);
              if (!keepLattice && bb <= 0.001) continue;
              let keep = true;
              if (!keepLattice) {
                const exponent = 1 + s;
                const keepProb = Math.pow(bb, exponent);
                const noise = pseudoRandomFromCoords(x, y);
                if (noise > keepProb) keep = false;
              }
              if (!keep) continue;
              let r;
              if (keepLattice) {
                const minR = dotSizes.small * 0.4;
                const maxR = dotSizes.large;
                r = minR + bb * (maxR - minR);
              } else {
                const bucket = Math.min(2, Math.floor(bb * 3));
                r = sizes[bucket];
              }
              if (r <= 0.01) continue;
              dots.push({ x, y, r });
            }
            const perfHint = document.getElementById("perfHint");
            if (perfHint) perfHint.textContent = "";
            return dots;
          }
          if (rule === "randomScatter") {
            return placementRandomScatter(
              width,
              height,
              getBrightness,
              dotSizes,
              true,
              4243,
              Math.round(12000 * dotCountFactor),
            );
          }

          let candidates;
          if (rule === "grid")
            candidates = placementGrid(width, height, cell, getBrightness);
          else if (rule === "gridJitter") {
            const rng = mulberry32(4242);
            candidates = placementGridJitter(
              width,
              height,
              cell,
              getBrightness,
              rng,
              0.85,
            );
          } else if (rule === "staggeredGrid")
            candidates = placementStaggeredGrid(
              width,
              height,
              cell,
              getBrightness,
            );
          else if (rule === "hexagonal")
            candidates = placementHexagonal(width, height, cell, getBrightness);
          else {
            const rng = mulberry32(4242);
            candidates = placementGridJitter(
              width,
              height,
              cell,
              getBrightness,
              rng,
              0.85,
            );
          }

          const keepLattice = !!state.type3KeepLattice;
          for (let i = 0; i < candidates.length; i++) {
            const { x, y, b } = candidates[i];
            const bb = clamp01(b);
            if (!keepLattice && bb <= 0.001) continue;

            let r;
            if (keepLattice) {
              // Option C: map brightness continuously to radius, keeping
              // every lattice point instead of probabilistically removing.
              const minR = dotSizes.small * 0.4;
              const maxR = dotSizes.large;
              r = minR + bb * (maxR - minR);
            } else {
              const bucket = Math.min(2, Math.floor(bb * 3));
              r = sizes[bucket];
            }
            if (r <= 0.01) continue;
            dots.push({ x, y, r });
          }
          const perfHint = document.getElementById("perfHint");
          if (perfHint) perfHint.textContent = "";
          return dots;
        }

        const radius = Math.max(1, Math.floor((gridSpacing / eff) / 3));
        const thresh =
          dotCountFactor > 1
            ? Math.max(0.01, 0.05 * (2 - dotCountFactor))
            : 0.05;
        const peaks = findBrightnessPeaks({
          radius,
          threshold: thresh,
          minDist: 0,
          step: 1,
        });
        for (let i = 0; i < peaks.length; i++) {
          const { x, y, b } = peaks[i];
          const bucket = Math.min(2, Math.floor(b * 3));
          const r = sizes[bucket];
          if (r <= 0.01) continue;
          dots.push({ x, y, r });
        }
        const perfHint = document.getElementById("perfHint");
        if (perfHint) perfHint.textContent = "";
        return dots;
      }

      function renderType3(params) {
        let dots =
          state.dotsCache[3] || (state.dotsCache[3] = computeDotsType3(params));
        dots = applyDotCountFactor(
          dots,
          state.dotCountFactor,
          params.getBrightness,
        );
        const ctx = canvases[3].getContext("2d");
        drawDotsToCanvas(ctx, dots);
      }

      // ---------- Algorithm: Type 4 – Fixed Grid + Fixed Size ----------
      // Fixed grid, fixed dot size. Dots at cell centers where cell is bright.
      // Brightness from selected detection method.

      function computeDotsType4(params) {
        const { width, height, gridSpacing, dotSizes, dotCountFactor = 1 } =
          params;
        const dots = [];
        const eff = dotCountFactor > 1 ? Math.sqrt(dotCountFactor) : 1;
        const cell = Math.max(2, gridSpacing / eff);
        const r = dotSizes.medium; // fixed size for Type 4
        if (r <= 0.01) return dots;

        for (let y = 0; y < height; y += cell) {
          const cy = y + cell / 2;
          for (let x = 0; x < width; x += cell) {
            const cx = x + cell / 2;
            const b = getCellBrightness(cx, cy, cell);
            if (b <= 0.001) continue;
            dots.push({ x: cx, y: cy, r });
          }
        }

        return dots;
      }

      function renderType4(params) {
        let dots =
          state.dotsCache[4] || (state.dotsCache[4] = computeDotsType4(params));
        dots = applyDotCountFactor(
          dots,
          state.dotCountFactor,
          params.getBrightness,
        );
        const ctx = canvases[4].getContext("2d");
        drawDotsToCanvas(ctx, dots);
      }

      // ---------- Master render loop using requestAnimationFrame ----------

      function renderAllTypes() {
        if (!state.grayBuffer || !state.width || !state.height) return;
        resizeCanvases();

        const params = buildCommonParams();

        // For disabled types, clear canvas to background only.
        for (const t of [1, 2, 3, 4]) {
          const canvas = canvases[t];
          if (!canvas) continue;
          if (!state.enabledTypes[t]) {
            const ctx = canvas.getContext("2d");
            drawDotsToCanvas(ctx, []); // background only
          }
        }

        if (state.enabledTypes[1]) renderType1(params);
        if (state.enabledTypes[2]) renderType2(params);
        if (state.enabledTypes[3]) renderType3(params);
        if (state.enabledTypes[4]) renderType4(params);
      }

      function animationLoop() {
        if (state.needsRender) {
          state.needsRender = false;
          renderAllTypes();
        }
        requestAnimationFrame(animationLoop);
      }

      // ---------- SVG export ----------

      function exportSvgForType(type) {
        if (!state.grayBuffer || !state.width || !state.height) return;
        const t = parseInt(type, 10);

        const params = buildCommonParams();

        let dots = state.dotsCache[t];
        if (!dots) {
          if (t === 1) dots = computeDotsType1(params);
          else if (t === 2) dots = computeDotsType2(params);
          else if (t === 3) dots = computeDotsType3(params);
          else if (t === 4) dots = computeDotsType4(params);
        }
        dots = applyDotCountFactor(
          dots,
          state.dotCountFactor,
          params.getBrightness,
        );
        if (!dots || dots.length === 0) return;

        const W = state.width;
        const H = state.height;
        let svg = "";
        svg += `<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">`;
        svg += `<rect width="100%" height="100%" fill="#05060a"/>`;
        const shape = state.dotShape || "circle";
        for (let i = 0; i < dots.length; i++) {
          const d = dots[i];
          const r = d.r;
          if (r <= 0) continue;
          if (shape === "square") {
            const size = (r * 2).toFixed(3);
            const x = (d.x - r).toFixed(3);
            const y = (d.y - r).toFixed(3);
            svg += `<rect x="${x}" y="${y}" width="${size}" height="${size}" fill="white" />`;
          } else {
            svg += `<circle cx="${d.x.toFixed(3)}" cy="${d.y.toFixed(3)}" r="${r.toFixed(
              3,
            )}" fill="white" />`;
          }
        }
        svg += `</svg>`;

        const blob = new Blob([svg], { type: "image/svg+xml" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `halftone-type${t}.svg`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // ---------- Controls wiring ----------

      function setupControls() {
        const gridSpacing = document.getElementById("gridSpacing");
        const dotSizeStep = document.getElementById("dotSizeStep");
        const contrastMultiplier =
          document.getElementById("contrastMultiplier");
        const dotShapeSelect = document.getElementById("dotShape");
        const brightnessMethodSelect =
          document.getElementById("brightnessMethod");
        const invertToggle = document.getElementById("invertToggle");
        const type1KeepLatticeToggle = document.getElementById(
          "type1KeepLatticeToggle",
        );
        const type3KeepLatticeToggle = document.getElementById(
          "type3KeepLatticeToggle",
        );

        const gridSpacingValue = document.getElementById("gridSpacingValue");
        const dotSizeStepValue = document.getElementById("dotSizeStepValue");
        const contrastMultiplierValue = document.getElementById(
          "contrastMultiplierValue",
        );
        const poissonMinDistance =
          document.getElementById("poissonMinDistance");
        const poissonMinDistanceValue = document.getElementById(
          "poissonMinDistanceValue",
        );
        const rotatedGridAngle = document.getElementById("rotatedGridAngle");
        const rotatedGridAngleValue = document.getElementById(
          "rotatedGridAngleValue",
        );
        const rotatedGridThreshold =
          document.getElementById("rotatedGridThreshold");
        const rotatedGridThresholdValue = document.getElementById(
          "rotatedGridThresholdValue",
        );
        const rotatedGridToneSpacing =
          document.getElementById("rotatedGridToneSpacing");
        const rotatedGridToneSpacingValue = document.getElementById(
          "rotatedGridToneSpacingValue",
        );
        const shadowsLevel = document.getElementById("shadowsLevel");
        const midtonesLevel = document.getElementById("midtonesLevel");
        const highlightsLevel = document.getElementById("highlightsLevel");
        const shadowsLevelValue = document.getElementById("shadowsLevelValue");
        const midtonesLevelValue = document.getElementById("midtonesLevelValue");
        const highlightsLevelValue =
          document.getElementById("highlightsLevelValue");
        const dotCountFactorEl = document.getElementById("dotCountFactor");
        const dotCountFactorValue =
          document.getElementById("dotCountFactorValue");

        function syncLabels() {
          gridSpacingValue.textContent = `${state.gridSpacing.toFixed(0)} px`;
          const sz = getDotSizes();
          dotSizeStepValue.textContent = `${sz.small.toFixed(1)} / ${sz.medium.toFixed(1)} / ${sz.large.toFixed(1)} px`;
          contrastMultiplierValue.textContent = `${state.contrastMultiplier.toFixed(
            2,
          )}×`;
          if (poissonMinDistanceValue)
            poissonMinDistanceValue.textContent = `${(state.poissonMinDistanceScale != null ? state.poissonMinDistanceScale : 1).toFixed(1)}×`;
          if (rotatedGridAngleValue)
            rotatedGridAngleValue.textContent = `${(state.rotatedGridAngleDeg || 0).toFixed(0)}°`;
          if (rotatedGridThresholdValue)
            rotatedGridThresholdValue.textContent = `${(state.rotatedGridThreshold != null ? state.rotatedGridThreshold : 0.05).toFixed(3)}`;
          if (rotatedGridToneSpacingValue)
            rotatedGridToneSpacingValue.textContent = `${(state.rotatedGridToneSpacingStrength != null ? state.rotatedGridToneSpacingStrength : 1).toFixed(2)}×`;
          if (shadowsLevelValue)
            shadowsLevelValue.textContent = state.levelsShadows.toFixed(2);
          if (midtonesLevelValue)
            midtonesLevelValue.textContent = state.levelsMidtones.toFixed(2);
          if (highlightsLevelValue)
            highlightsLevelValue.textContent =
              state.levelsHighlights.toFixed(2);
          if (dotCountFactorValue)
            dotCountFactorValue.textContent = `${Math.round(
              (state.dotCountFactor || 1) * 100,
            )}%`;
        }

        // Initialize from default state
        state.gridSpacing = Number(gridSpacing.value);
        state.dotSizeStep = Number(dotSizeStep.value) | 0;
        state.contrastMultiplier = Number(contrastMultiplier.value);
        state.levelsShadows = shadowsLevel ? Number(shadowsLevel.value) : 0;
        state.levelsMidtones = midtonesLevel ? Number(midtonesLevel.value) : 1;
        state.levelsHighlights = highlightsLevel
          ? Number(highlightsLevel.value)
          : 1;
        state.dotCountFactor = dotCountFactorEl
          ? Number(dotCountFactorEl.value)
          : 1;
        state.dotShape = dotShapeSelect.value || "circle";
        const brightnessDetectionToggle = document.getElementById(
          "brightnessDetectionToggle",
        );
        state.brightnessDetectionEnabled = brightnessDetectionToggle
          ? brightnessDetectionToggle.checked
          : true;
        state.brightnessMethod = brightnessMethodSelect
          ? brightnessMethodSelect.value || "mean"
          : "mean";
        state.invert = Boolean(invertToggle.checked);
        const placementRuleSelect = document.getElementById("placementRule");
        state.placementRule = placementRuleSelect
          ? placementRuleSelect.value || "gridJitter"
          : "gridJitter";
        state.poissonMinDistanceScale = poissonMinDistance
          ? Number(poissonMinDistance.value) || 1
          : 1;
        state.rotatedGridAngleDeg = rotatedGridAngle
          ? Number(rotatedGridAngle.value) || 45
          : 45;
        state.rotatedGridThreshold = rotatedGridThreshold
          ? Number(rotatedGridThreshold.value) || 0.05
          : 0.05;
        state.type1KeepLattice = type1KeepLatticeToggle
          ? type1KeepLatticeToggle.checked
          : false;
        state.type3KeepLattice = type3KeepLatticeToggle
          ? type3KeepLatticeToggle.checked
          : false;
        state.rotatedGridToneSpacingStrength = rotatedGridToneSpacing
          ? Number(rotatedGridToneSpacing.value) || 1
          : 1;
        state.enabledTypes = { 1: false, 2: false, 3: false, 4: false };
        syncLabels();

        gridSpacing.addEventListener("input", () => {
          state.gridSpacing = Number(gridSpacing.value);
          syncLabels();
          markNeedsRender();
        });

        dotSizeStep.addEventListener("input", () => {
          state.dotSizeStep = Math.max(0, parseInt(dotSizeStep.value, 10) || 0);
          syncLabels();
          markNeedsRender();
        });

        contrastMultiplier.addEventListener("input", () => {
          state.contrastMultiplier = Number(contrastMultiplier.value);
          syncLabels();
          markNeedsRender();
        });

        if (shadowsLevel) {
          shadowsLevel.addEventListener("input", () => {
            state.levelsShadows = Number(shadowsLevel.value);
            syncLabels();
            markNeedsRender();
          });
        }
        if (midtonesLevel) {
          midtonesLevel.addEventListener("input", () => {
            state.levelsMidtones = Number(midtonesLevel.value);
            syncLabels();
            markNeedsRender();
          });
        }
        if (highlightsLevel) {
          highlightsLevel.addEventListener("input", () => {
            state.levelsHighlights = Number(highlightsLevel.value);
            syncLabels();
            markNeedsRender();
          });
        }
        if (dotCountFactorEl) {
          dotCountFactorEl.addEventListener("input", () => {
            state.dotCountFactor = Number(dotCountFactorEl.value);
            syncLabels();
            markNeedsRender();
          });
        }

        invertToggle.addEventListener("change", () => {
          state.invert = invertToggle.checked;
          markNeedsRender();
        });

        dotShapeSelect.addEventListener("change", () => {
          state.dotShape = dotShapeSelect.value || "circle";
          markNeedsRender();
        });

        if (brightnessMethodSelect) {
          brightnessMethodSelect.addEventListener("change", () => {
            state.brightnessMethod = brightnessMethodSelect.value || "mean";
            markNeedsRender();
          });
        }
        if (brightnessDetectionToggle) {
          brightnessDetectionToggle.addEventListener("change", () => {
            state.brightnessDetectionEnabled =
              brightnessDetectionToggle.checked;
            if (brightnessMethodSelect)
              brightnessMethodSelect.disabled =
                !state.brightnessDetectionEnabled;
            markNeedsRender();
          });
          if (brightnessMethodSelect)
            brightnessMethodSelect.disabled = !state.brightnessDetectionEnabled;
        }
        if (placementRuleSelect) {
          placementRuleSelect.addEventListener("change", () => {
            state.placementRule = placementRuleSelect.value || "gridJitter";
            markNeedsRender();
          });
        }
        if (poissonMinDistance) {
          poissonMinDistance.addEventListener("input", () => {
            state.poissonMinDistanceScale =
              Number(poissonMinDistance.value) || 1;
            syncLabels();
            markNeedsRender();
          });
        }
        if (rotatedGridToneSpacing) {
          rotatedGridToneSpacing.addEventListener("input", () => {
            state.rotatedGridToneSpacingStrength =
              Number(rotatedGridToneSpacing.value) || 0;
            syncLabels();
            markNeedsRender();
          });
        }
        if (type1KeepLatticeToggle) {
          type1KeepLatticeToggle.addEventListener("change", () => {
            state.type1KeepLattice = type1KeepLatticeToggle.checked;
            markNeedsRender();
          });
        }
        if (type3KeepLatticeToggle) {
          type3KeepLatticeToggle.addEventListener("change", () => {
            state.type3KeepLattice = type3KeepLatticeToggle.checked;
            markNeedsRender();
          });
        }
        if (rotatedGridAngle) {
          rotatedGridAngle.addEventListener("input", () => {
            state.rotatedGridAngleDeg = Number(rotatedGridAngle.value) || 0;
            syncLabels();
            markNeedsRender();
          });
        }
        if (rotatedGridThreshold) {
          rotatedGridThreshold.addEventListener("input", () => {
            state.rotatedGridThreshold =
              Number(rotatedGridThreshold.value) || 0;
            syncLabels();
            markNeedsRender();
          });
        }

        document
          .getElementById("imageLoader")
          .addEventListener("change", handleFileInput);

        const exportButtons = document.querySelectorAll(".export-btn");
        exportButtons.forEach((btn) => {
          btn.addEventListener("click", () => {
            const type = btn.getAttribute("data-type");
            exportSvgForType(type);
          });
        });

        const typeToggles = document.querySelectorAll(".type-toggle");
        typeToggles.forEach((cb) => {
          cb.addEventListener("change", () => {
            const type = parseInt(cb.getAttribute("data-type"), 10);
            const checked = cb.checked;
            state.enabledTypes[type] = checked;
            markNeedsRender();
          });
        });
      }

      // ---------- Bootstrapping ----------

      document.addEventListener("DOMContentLoaded", () => {
        canvases[1] = document.getElementById("canvas1");
        canvases[2] = document.getElementById("canvas2");
        canvases[3] = document.getElementById("canvas3");
        canvases[4] = document.getElementById("canvas4");

        setupControls();
        animationLoop(); // start continuous requestAnimationFrame loop
      });
    </script>
  </body>
</html>
